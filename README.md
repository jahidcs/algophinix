# Algophinix

- Phase 1 â€“ Foundations: Master problem-solving basics, time/space complexity, and core coding patterns.
- Phase 2 â€“ Core Data Structures: Learn and implement arrays, strings, linked lists, stacks, queues, and hashmaps.
- Phase 3 â€“ Algorithms Fundamentals: Get comfortable with sorting, searching, recursion, and divide-and-conquer.
- Phase 4 â€“ Advanced DS & Algos: Explore trees, heaps, graphs, greedy, dynamic programming, and backtracking.
- Phase 5 â€“ System-Level Thinking: Apply DSA to real-world problems with caching, concurrency, and scalability concepts.
- Phase 6 â€“ Mastery & Projects: Solve advanced problems, participate in contests, build projects, and create content.

## **Phase 1: Foundations (Warm-Up)**

ðŸŽ¯ Goal: Build problem-solving mindset, get comfortable with time/space complexity.

- **Big-O Analysis** â†’ Time complexity, Space complexity.
- **Math Basics** â†’ GCD, LCM, Prime checking, Fast Exponentiation.
- **Bit Manipulation** â†’ Set/clear bits, check odd/even, subset generation.

ðŸ“Œ _Output:_ Cheatsheets + small problems.

---

## **Phase 2: Arrays & Strings**

ðŸŽ¯ Goal: Get comfortable with iteration, hashing, sliding window, two pointers.

- Arrays

  - Two Sum / Pair Sum
  - Majority Element
  - Subarray with Given Sum
  - Trapping Rain Water
  - Stock Buy-Sell Problem
  - Smallest Missing Number

- Strings

  - Reverse words in string
  - Check anagrams
  - String rotations
  - Longest Common Subsequence (LCS)
  - Smallest window containing another string

ðŸ“Œ _Output:_ Implement in **Python first**, then re-implement 2â€“3 in **C++/Go**.

---

## **Phase 3: Linked Lists, Stacks, Queues**

ðŸŽ¯ Goal: Understand pointers, references, recursion, and stack/queue applications.

- **Linked List**: Reverse, Detect loop, Merge 2 lists, Add numbers.
- **Stack**: Balanced parentheses, Min Stack, Expression evaluation.
- **Queue**: Implement queue using stacks, BFS traversal, LRU Cache.

ðŸ“Œ _Output:_ Custom implementations from scratch in multiple languages.

---

## **Phase 4: Trees & Binary Search Trees**

ðŸŽ¯ Goal: Recursion + hierarchical thinking + search optimizations.

- **Binary Tree**: Traversals (DFS, BFS), Diameter, Lowest Common Ancestor.
- **BST**: Insert/Delete/Search, Kth smallest/largest, Balanced BST.
- **Advanced**: Serialize/Deserialize tree, Binary Tree â†’ DLL.

ðŸ“Œ _Output:_ Draw recursion trees for understanding + implement iterative and recursive approaches.

---

## **Phase 5: Advanced Data Structures**

ðŸŽ¯ Goal: Learn abstract DS for real-world efficiency.

- **Heap**: Build heap, kth largest/smallest, Median in stream.
- **Hashing**: Hashmap problems, Subarray sum 0, Vertical sum in tree.
- **Trie**: Word dictionary, Prefix matching, Auto-complete system.

ðŸ“Œ _Output:_ Build your own **Heap/HashMap/Trie** implementations.

---

## **Phase 6: Graph Algorithms**

ðŸŽ¯ Goal: Master connectivity, shortest paths, MST.

- Representations (Adjacency List, Matrix).
- Traversals: BFS, DFS.
- Cycle Detection (Directed/Undirected).
- Shortest Paths: Dijkstra, Bellman-Ford, Floyd-Warshall.
- MST: Kruskal, Prim.
- Topological Sort, Strongly Connected Components (Kosaraju/Tarjan).

ðŸ“Œ _Output:_ Visualize graph traversals + solve on real-world problems (social network, map).

---

## **Phase 7: Dynamic Programming (DP)**

ðŸŽ¯ Goal: Build optimization mindset, practice patterns.

- **Classic Problems**

  - Fibonacci, LIS, LCS, Knapsack.
  - Coin Change, Matrix Chain Multiplication.
  - Minimum Path Sum, Partition Problem.

- **Advanced DP**

  - DP on Trees (diameter, max path).
  - DP on Graphs (shortest paths).
  - Bitmask DP.

ðŸ“Œ _Output:_ Maintain a **DP Pattern Notebook** (recurrence â†’ memoization â†’ tabulation).

---

## **Phase 8: Advanced / System-Level Problems**

ðŸŽ¯ Goal: Go beyond interviews â†’ prepare for large-scale engineering.

- Caching: LRU, LFU.
- Segment Trees & Fenwick Trees (Range queries).
- Disjoint Set Union (Union-Find, Kruskalâ€™s).
- String Algorithms (KMP, Rabin-Karp, Suffix Arrays/Trie).
- Real-World: Rate Limiter, Scheduling, Sharding logic.

ðŸ“Œ _Output:_ Connect algorithms to **system design** topics.

---
